

// 第02章 初出茅庐——初级篇
/*
	
*/

// __________________________2.1 最基础的“穷竭搜索”__________________________
/*
	穷竭搜索是将所有的可能性罗列出来，在其中寻找答案的方法。这里我们主要介绍【深度优先搜索】和【广度优先搜索】这两种方法。
*/

// 2.1.1 递归函数
/* 
	在一个函数中再次调用该函数自身的行为叫做递归，这样的函数被称作递归函数。

	在编写一个递归函数时，函数的停止条件是必须存在的。
*/	

// 【阶乘】的递推式 n! = n*(n-1)!
int fact(int n){
	if( n == 0 )return 1;
	return n* fact(n-1);
}

// 计算 【斐波那契】 数列的函数 
int fib(int n){
	if(n<=1)return n;
	return fib(n-1) + fib(n-2);
}

/*
	实际使用这个函数时，即便是求 fib(40) 这样的 n 较小的结果，也要花费相当长的时间。
	这是因为这个函数在递归时，会像下图一样按照指数级别扩展开来。
	fib(10) = fib(9) + fib(8)
	fib(9) = fib(8) + fib(7)
	
	如果计算一次后，用数列将结果存储起来，便可优化之后的计算。fib(10)被调用时同样的n被计算了很多次，
	因此可以获得很大的优化空间。这种方法是出于记忆化搜索或者动态规划的想法。
*/

int memo[MAX_N + 1];

int fib(int n){
	if(n<=1)return n;
	if(memo[n] != 0)return memo[n];
	return memo[n] = fib(n-1) + fib(n-2);
}

// 2.1.2 栈
/*
	栈(Stack)是支持push和pop两种操作的数据结构。
	(LIFO:Last In First Out,	既后进先出 )

	C++的标准库中，stack::pop()完成的仅仅是移除最顶端的数据。
	如果需要访问最顶端的数据，需要使用stack::top()函数【这个操作通常也被称为peek】
*/

// 2.1.3 队列
/*

*/	