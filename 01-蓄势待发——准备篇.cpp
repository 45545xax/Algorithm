

// 第01章 蓄势待发——准备篇
/*
	
*/

// __________________________1.1 何谓程序设计竞赛__________________________
/*
	抽签
	你的朋友提议玩一个游戏：将写有数字的n个纸片放入口袋中，你可以从口袋中抽取4次纸片，每次记下纸片上的数字后都将其放回口袋中。
	如果这4个数字的和是m,就是你赢，否则就是你的朋友赢。
	请你编写一个程序，判断当纸片上所写的数字是k1,k2,...,kn时，是否存在抽取4次和为m的方案。如果存在，输出Yes;否则，输出No

	限制条件
	1<=n<=50
	1<=m<=10的8次
	1<=ki<=10的8次

	样例：
输入：	n = 3
		m = 10
		k = {1,3,5}
输出：  Yes,例如4次抽取的结果是 1,1,3,5 和就是 10 


	方案:4重循环穷举。
*/



// __________________________1.2 最负盛名的程序设计竞赛__________________________

// 1.2.1  	Google Code Jam (GCJ)		http://code.google.com/codejam/
// 1.2.2  	TopCoder
// 1.2.3 	ACM (大学生)
// 1.2.4	IOI(初中，高中)
/* 1.2.5 	Online Judge(OJ)
	
	PKU Online Judge(POJ) 			http://poj.org
	题库中有大量的题目

	Sphere Online Judge(SPOJ)		http://www.spoj.pl/
	允许使用各种各样的编程语言

	SGU Online Contester			http://acm.sgu.ru/
	具有模拟参加历史比赛的虚拟赛功能

	Codeforces						http://codeforces.com
	不断维护历届题库
*/ 



// __________________________1.4 如何提交解答__________________________




// __________________________1.6 轻松热身__________________________
// 1.6.1 先从简单题开始
/*
	三角形
	有n根棍子，棍子的长度为ai.想要从中选出3根棍子组成周长尽可能长的三角形。
	请输出最大的周长，若无法组成三角形则输出0.

	限制条件
	3<=n<=100
	1<=a[i]<=10的6次

	样例：
输入：	n = 5
		a = {2,3,4,5,10}
输出：  12 		
*/	

/*
	书上用的方法：首先用三重循环枚举所有棍子的选择方案，再利用上式判断能否组成三角形。如果可以，那么该三角形就是备选方案。
	这里用了三重循环，所以复杂度是O(n的3次)
*/

/*	改进方法
	首先对数组排序，然后从最大的数字开始，只要遍历1遍就可以找到周长最长的 三角形。
	所以这里的复杂度其实是涉及到一个排序。
*/	
i = n;	
longgirth = 0;
while(i-2>-1)
{
	if(a[i]<a[i-1]+a[i-2]) 
	{
		longgirth = a[i] + a[i-1] + a[i-2];
		break;
	}
	i--;
}



// 1.6.2 POJ的题目Ants
/*
	蚂蚁
	n只蚂蚁以每秒1cm的速度在长为Lcm的竿子上爬行。当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，
	它们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离xi,【但不知道它当前的朝向】。
	请计算所有蚂蚁落下竿子所需的最短时间和最长时间。

	限制条件
	1<=L<=10的6次
	1<=n<=10的6次
	0<=xi<=L

输入：	L = 10
		n = 3
		a = {2,6,7}
输出：  12 		
*/

/*
分析：
	1如果用穷举法，每只蚂蚁的初始朝向都有2种可能，n只蚂蚁就是2*2*2*...*2=2的n种。 则时间复杂度增长为 2的n次方。
	一般把指数阶的运行时间叫做指数时间。指数时间的算法无法处理稍大规模的输入。

	2换一种思路。两只蚂蚁相遇后朝反方向走。可以认为是【保存原样交错而过】。
	这样不论最长时间还是最短时间，都只要对每只蚂蚁检查一次就好了。这是O(n)时间的算法。

	这个问题可以说是 考察想象力类型问题的经典例子。有很多这样的问题，虽然开始不太明白，
	但想通之后，最后的程序却是出乎意料地简单。
*/