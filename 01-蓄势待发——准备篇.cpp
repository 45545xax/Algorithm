

// 第01章 蓄势待发——准备篇
/*
	
*/

// __________________________1.1 何谓程序设计竞赛__________________________
/*
	抽签
	你的朋友提议玩一个游戏：将写有数字的n个纸片放入口袋中，你可以从口袋中抽取4次纸片，每次记下纸片上的数字后都将其放回口袋中。
	如果这4个数字的和是m,就是你赢，否则就是你的朋友赢。
	请你编写一个程序，判断当纸片上所写的数字是k1,k2,...,kn时，是否存在抽取4次和为m的方案。如果存在，输出Yes;否则，输出No

	限制条件
	1<=n<=50
	1<=m<=10^8
	1<=ki<=10^8

	样例：
输入：	n = 3
		m = 10
		k = {1,3,5}
输出：  Yes,例如4次抽取的结果是 1,1,3,5 和就是 10 


	方案:4重循环穷举。
*/



// __________________________1.2 最负盛名的程序设计竞赛__________________________

// 1.2.1  	Google Code Jam (GCJ)		http://code.google.com/codejam/
// 1.2.2  	TopCoder
// 1.2.3 	ACM (大学生)
// 1.2.4	IOI(初中，高中)
/* 1.2.5 	Online Judge(OJ)
	
	PKU Online Judge(POJ) 			http://poj.org
	题库中有大量的题目

	Sphere Online Judge(SPOJ)		http://www.spoj.pl/
	允许使用各种各样的编程语言

	SGU Online Contester			http://acm.sgu.ru/
	具有模拟参加历史比赛的虚拟赛功能

	Codeforces						http://codeforces.com
	不断维护历届题库
*/ 



// __________________________1.4 如何提交解答__________________________




// __________________________1.6 轻松热身__________________________
// 1.6.1 先从简单题开始
/*
	三角形
	有n根棍子，棍子的长度为ai.想要从中选出3根棍子组成周长尽可能长的三角形。
	请输出最大的周长，若无法组成三角形则输出0.

	限制条件
	3<=n<=100
	1<=a[i]<=10^6

	样例：
输入：	n = 5
		a = {2,3,4,5,10}
输出：  12 		
*/	

/*
	书上用的方法：首先用三重循环枚举所有棍子的选择方案，再利用上式判断能否组成三角形。如果可以，那么该三角形就是备选方案。
	这里用了三重循环，所以复杂度是O(n^3)
*/

/*	改进方法
	首先对数组排序，然后从最大的数字开始，只要遍历1遍就可以找到周长最长的 三角形。
	所以这里的复杂度其实是涉及到一个排序。
*/	
i = n;	
longgirth = 0;
while(i-2>-1)
{
	if(a[i]<a[i-1]+a[i-2]) 
	{
		longgirth = a[i] + a[i-1] + a[i-2];
		break;
	}
	i--;
}



// 1.6.2 POJ的题目Ants
/*
	蚂蚁
	n只蚂蚁以每秒1cm的速度在长为Lcm的竿子上爬行。当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，
	它们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离xi,【但不知道它当前的朝向】。
	请计算所有蚂蚁落下竿子所需的最短时间和最长时间。

	限制条件
	1<=L<=10^6
	1<=n<=10^6
	0<=xi<=L

输入：	L = 10
		n = 3
		a = {2,6,7}
输出：  12 		
*/

/*
分析：
	1如果用穷举法，每只蚂蚁的初始朝向都有2种可能，n只蚂蚁就是2*2*2*...*2=2的n种。 则时间复杂度增长为 2^n。
	一般把指数阶的运行时间叫做指数时间。指数时间的算法无法处理稍大规模的输入。

	2换一种思路。两只蚂蚁相遇后朝反方向走。可以认为是【保存原样交错而过】。
	这样不论最长时间还是最短时间，都只要对每只蚂蚁检查一次就好了。这是O(n)时间的算法。

	这个问题可以说是 考察想象力类型问题的经典例子。有很多这样的问题，虽然开始不太明白，
	但想通之后，最后的程序却是出乎意料地简单。
*/



// 1.6.3 难度增加的抽签问题	
/*
1.二分搜索与O(n^3logn)的算法
	如果将最开始的抽签问题中关于n的限制条件改为1<=n<=1000. 则时间复杂度将大大提高。
	我们可以改进这个四重循环，先对数组进行排序，
	ka + kb + kc + kd = m
	kd = m - ka - kb - kc 
	然后在内层循环里，使用二分法 搜索查找kd
*/

	sort(k,k+n);									// 为了执行二分查找需要先排序。
	binary_search( m - k[a] - k[b] - k[c] );		// 将最内侧的循环替换成二分查找
/*	
	二分搜索算法每次将候选区间 减小至大约原来的一半。因此要盘点机长度为n的有序数组k中是否包含x，只要反复执行约 log2n次就可以完成了。
	二分查找的复杂度是O(logn)时间的，我们称这种阶的运行时间为对数时间，即便n变得很大时，对数时间的算法依然非常快速。

	排序O(nlogn)时间
	循环O(n^3logn)时间
	n^3logn 比 nlogn 大，所以这里合起来当做 O(n^3logn)时间。于是，我们得到了在 O(n^3logn)时间内解决抽取问题的算法。
*/

/*
2.O(n^2logn)的算法	
	刚才只是着眼与最内层的循环优化，但是还可以进一步优化，就是内侧的两个循环。
*/

