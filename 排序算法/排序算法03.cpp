

// 排序算法-03 
/*
    http://www.cnblogs.com/wb-DarkHorse/archive/2012/12/08/2779219.html
    有不少图片在里面。

	前面介绍的冒泡排序，插入排序，shell排序都是基于两两元素比较，然后移动的排序算法，有着O(N2)的复杂度，
    今天讲三种比较牛的排序算法，可以将复杂度降低为O(n*lgn)。分别是：1) 堆排序。2)归并排序。3）快速排序。
*/


// __________________________1 堆排序 __________________________
/*
	算法：利用二叉堆(binary heap)的数据结构形式，及其性质对数据进行排序。首先看下什么是二叉堆，wiki解释：

二叉堆是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值，且每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。

二叉堆一般用数组来表示，节点i的左儿子的序号是2i，右儿子节点的下标是2i+1.如下面的两个二叉堆(左边的为最小堆，右边的为最大堆)表示的数组分别为：{1,2,3,4,5,6,7,8,9,10,11}和{11,9,10,5,6,7,8,1,2,3,4}。

        1               11
      /   \           /   \
     2     3         9     10
    / \   / \       / \    / \
   4   5  6  7     5   6  7   8
  / \ / \         / \ / \
 8  9 10 11      1  2 3  4 
二叉堆一般有集中基本操作，首先看一下，给一个数组，怎么建立一个二叉堆：

数组为array[] = {2, 3, 1, 29, 70, 16, 34, 11, 10, 33, 79};先根据数组下标，它构成的完全二叉树是这样的：
*/
