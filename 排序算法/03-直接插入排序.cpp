

// 03-直接插入排序

// __________________________1 直接插入排序 __________________________
/*
	感觉就像是摸扑克牌，摸一张，就和手里的牌进行依次比较，选择合适的插入位置。
    然后再摸下一张，再和手里的所有牌进行对比，选择合适的插入位置。

    直观理解，就是玩扑克牌时，摸牌的那个阶段。
*/


/*
	方法：从数组的二个元素开始，设当前位置索引是i，通过找到当前元素array[i]在前面i个元素中的正确位置j后，将j位置及j到i-1位置中间的元素后移一位，
	然后将当前元素插在j位置，这样前i个元素变成有序的了，然后i++,再通过比较和插入使得前i+1个元素有序，直到最后。

     直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。
*/

void InsertSort(int arr[], int length)
{
    int i,j;
    int ntemp;
    for(i=1; i<length; i++)
    {
        ntemp = arr[i];
        for(j=i; j>0 && arr[j-1]>ntemp; j--)
            arr[j] = arr[j-1];
        arr[j] = ntemp;
    }
}	
/*
    时间复杂度分析：

    我们来分析一下这个算法，从空间上来看，它只需要一个记录的辅助空间。因此关键是看它的时间复杂度。

    当最好的情况，也就是要排序的表本身就是有序的，比如纸牌拿到后就是{2,3,4,5,6}，那么我们比较次数共比较n次，因此没有移动的记录，时间复杂度为O(n)。
    当最坏的情况，即待排序表是逆序的情况比如{6,5,4,3,2}，此时需要比较 (n+2)*(n-1)/2 次，而记录的移动次数也达到最大值 (n+4)*(n-1)/2 次。
    如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次约为(n^2)/4 次。因此，我们得出直接插入排序法的时间复杂度为O(n^2)。
    
    从这里也看出，同样的O(n2)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。
*/



/*
unsort array:
2 4 6 3 5 9 11
sort array:
2 3 4 5 6 9 11
*/

/*
	两种排序算法的时间复杂度都是O(N^2)。但是冒泡排序增加了哨兵指示，用来判断是否当前排序已经处于有序状态，从而避免没必要的比较。
	在一般的小数据排序时，这两种都是很好的选择，因为实现起来简单。
*/