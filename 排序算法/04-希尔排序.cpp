

// 排序算法-02
/*
	前面讲了冒泡排序和插入排序，今天讲的排序算法是shell排序-希尔排序

历史背景：
    优秀排序算法的首要条件就是速度(还有其他要求，速度是第一位的)。于是人们想了许许多多的办法，目的就是为了提高排序的速度。
    而在很长的时间里，众人发现尽管各种排序算法花样繁多（比如前面我们提到的三种不同的排序算法），但时间复杂度都是O(n2)，
    似乎没法超越了（这里排序指内排序）。此时，计算机学术界充斥着“排序算法不可能突破O(n^2)”的声音，“不可能”成了主流。

    终于有一天，当一位科学家发布超越了O(n^2)新排序算法后，紧接着就出现了好几种可以超越O(n^2)的排序算法，
    并把内排序算法的时间复杂度提升到了O(nlog2n)。“不可能超越O(n^2)”彻底成为了历史。

    现在，我要讲解的算法叫希尔排序（Shell Sort）。希尔排序是D.L.Shell于1959年提出来的一种排序算法，
    在这之前排序算法的时间复杂度基本都是O(n^2)的，希尔排序算法是突破这个时间复杂度的第一批算法之一。
*/

/*
思路起源：
    我们前一节讲的直接插入排序，应该说，它的效率在某些时候是很高的，比如，我们的记录本身就是基本有序的，我们只需要少量的插入操作，
    就可以完成整个记录集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也比较明显。
    可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。

    于是科学家希尔研究出了一种排序，对直接插入排序改进后可以增加效率的方法。
    如何让待排序的记录个数较少呢？很容易想到的就是将原本有大量记录数的记录进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了。
    然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。

    此时一定有同学开始疑惑了。这不对呀，比如我们现在有序列是{9,1,5,8,3,7,4,6,2}，现在将它分成三组，{9,1,5}，{8,3,7}，{4,6,2}，
    哪怕将它们各自排序排好了，变成{1,5,9}，{3,7,8}，{2,4,6}，再合并它们成{1,5,9,3,7,8,2,4,6}，此时，这个序列还是杂乱无序，谈不上基本有序，
    要排序还是重来一遍直接插入有序，这样做有用吗？

    需要强调一下，所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2,1,3,6,4,7,5,8,9}这样可以称为基本有序了。
    但像{1,5,9,3,7,8,2,4,6}这样的9在第三位，2在倒数第三位就谈不上基本有序。

    问题其实也就在这里，我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。
    而如上面这样分完组后，就各自排序的方法达不到我们的要求。因此，我们需要采取跳跃分割的策略：
    【将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。】       
*/


// __________________________1 希尔排序-shell排序 __________________________
/*
	shell排序命名来自于Donald Shell,该算法被证明为有亚二次时间界。是插入排序的一种改进，舍弃了插入排序逐一比较的不足之处，
    而是设定一个增量，间隔比较。然后逐渐缩小这个增量，最终达到排序目的，所以shell排序也叫缩减增量排序。

    首先，需要设定一组增量序列，h1,h2,...hk。然后先从h1开始，以此增量为步长，将全部序列分成若干组，每一组进行插入排序。
    接着增量变为h2，继续分组，然后再插入排序，这样直到最后。不同的增量序列带来的计算量不一样，
    本文以shell建议的增量序列为例进行算法说明，即h1=N/2,hk=hk-1/2。下面是具体步骤：
*/

void ShellSort(int arr[], int nlen)
{
    int i,j;
    int ntemp;
    int ngap;
    for(ngap=nlen/3 + 1; ngap>0; ngap=ngap/3+1)//shell增量序列
    {
        for(i=ngap; i<nlen; i++)//对于每个增量序列hi(hi对应的初始位置是i),处理其后的所有元素i+1,i+2,..N-1
        {
            ntemp = arr[i];
            for(j=i; j>=ngap && arr[j-ngap]>ntemp; j-=ngap)//对当前位置i的元素,将其插入到arri-hi,arri-2hi,...序列中。
            {
                arr[j] = arr[j-ngap];//这个跟插入排序的过程是一样的
            }
            arr[j] = ntemp;

            /******for test*********/
            cout<<"gap="<<ngap<<": ";
            PrintArray(arr, nlen);
            /***********************/
        }
    }
}

/*
    希尔排序复杂度分析
    通过这段代码的剖析，相信大家有些明白，希尔排序的关键并不是随便的分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，
    实现跳跃式的移动，使得排序的效率提高。
    
    这里“增量”的选取就非常关键了。我们在代码中第7行，是用increment=increment/3+1;的方式选取增量的，可究竟应该选取什么样的增量才是最好，
    目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。

        不过大量的研究表明，当增量序列为dlta[k]=2^(t-k+1)-1（0≤k≤t≤[log2(n+1)]）时，可以获得不错的效率，其时间复杂度为O(n^(3/2))，
    要好于直接排序的O(n^2)。需要注意的是，增量序列的最后一个增量值必须等于1才行。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。

    不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度为O(n^2)），之后，相应的更为高效的排序算法也就相继出现了。
*/



// 测试
void PrintArray(int arr[], int nlen)
{
    int i;
    for(i=0; i<nlen; i++)
    {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

int _tmain(int argc, _TCHAR* argv[])
{
    int data[] = {2, 3, 1, 29, 70, 16, 34, 11, 10, 33, 79, 6, 46, 100, 25, 82};
    PrintArray(data, 16);
    ShellSort(data, 16);
    PrintArray(data, 16);

    return 0;
}

// 结果：
unsort 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82

gap=8: 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82
gap=8: 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82
gap=8: 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82
gap=8: 2 3 1 6 70 16 34 11 10 33 79 29 46 100 25 82
gap=8: 2 3 1 6 46 16 34 11 10 33 79 29 70 100 25 82
gap=8: 2 3 1 6 46 16 34 11 10 33 79 29 70 100 25 82
gap=8: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=8: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=4: 2 3 1 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 33 46 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 3 2 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 34 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 34 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 79 82 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 79 82 100

sort:  1 2 3 6 10 11 16 25 29 33 34 46 70 79 82 100

 /*
自己动手分析一下结果就知道中间运行的具体过程了，很好理解。其实shell增量不一定是最好的，也可以选择其它的增量序列，
这里不再叙述，<<数据结构与算法分析-c++描述>>的排序算法里面有介绍。
 */

