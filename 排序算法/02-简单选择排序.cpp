

// 02-简单选择排序

/*
    一种最简单的排序算法是这样的，
    01 首先，找到数组中最小的那个元素。
    02 其次，将它和数组的第一个元素交换位置。（如果第1个元素就是最小元素那么它就和自己交换）。
    03 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。
    如此往复，直到将整个数组排序。 这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

    选择排序的内循环只是在比较当前元素与目前已知的最小元素。交换元素的代码写在内循环之外，每次交换都能排定一个元素，因此交换的总次数是N。
    所以算法的时间效率取决于比较的次数。

    对于长度为N的数组，选择排序需要大约(N^2)/2次比较+N次交换。
    总的来说：选择排序是一种很容易理解和实现的简单排序算法，它有两个很鲜明的特点。
01 运行时间和输入无关：
    为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人会发现：
    一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！
02 数据移动是最少的：    
    每次交换都会改变两个数组元素的值，因此选择排序用了N次交换————交换次数和数组的大小是线性关系。
*/

/*
	爱炒股票短线的人，总是喜欢不断的买进卖出，想通过价差来实现盈利。但通常这种频繁操作的人，即使失误不多，也会因为操作的手续费和印花税过高而获利很少。
    还有一种做股票的人，他们很少出手，只是在不断的观察和判断，等到时机一到，果断买进或卖出。他们因为冷静和沉着，以及交易的次数少，而最终收益颇丰。 

    冒泡排序的思想就是不断的在交换，通过交换完成最终的排序，这和做股票短线频繁操作的人是类似的。
    我们可不可以像只有在时机非常明确到来时才出手的股票高手一样，也就是在排序时找到合适的关键字再做交换，
    并且只移动一次就完成相应关键字的排序定位工作呢？这就是选择排序法的初步思想。

    选择排序的基本思想是每一趟在n-i+1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。我们这里先介绍的是简单选择排序法。
    简单选择排序法（Simple Selection Sort）就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1≤i≤n)个记录交换之。
    我们来看代码。
*/
// 【交换函数】-C++ 版-模板：可以针对不同类型,不局限于 int 类型。
template <typename type>  
void swip(type &a, type &b)  
{  
    type temp = a;
    a = b;
    b = tmep; 
}  


void SelectSort0(int array[], int length)   // length 为数组的长度。
{
    int i,j,min;
    for(i = 0;i<length;i++)
    {
        min = i;
        for(j=i+1;j<length;j++)   
        {
            if( array[j]<array[min] ) 
            {
               min = j;
            }
        }

        if(i!=min)
        {
            swap(array[i],array[min]);
        }
         
    }
}


/*
     代码应该说不难理解，针对待排序的关键字序列是{9,1,5,8,3,7,4,6,2}，对i从1循环到8。当i=0时，array[i]=9，min开始是0，
     然后与j=1到8比较array[min]与array[j]的大小，因为j=1时最小，所以min=1。最终交换了array[1]与array[0]的值。
     注意，这里比较了8次，却只交换数据操作一次。
*/

/*
    复杂度分析：
    从简单选择排序的过程来看，它最大的特点就是【交换移动数据次数相当少】，这样也就节约了相应的时间。

    分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，

    而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，
    基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n^2)。

    应该说，尽管与冒泡排序同为O(n^2)，但简单选择排序的性能上还是要略优于冒泡排序。
*/

/*
    优化后的冒泡虽然最好的情况下时间复杂度为O(n)，但是出现概率比较小.
*/


// __________________________ __________________________  自我练习 __________________________ __________________________
/// 自己练习 多敲打几遍。
 void selectSort(int array[],int length)
 {
    for(int i = 0;i<length;i++)
    {
        int min = i;
        for(int j = i+1;j<length;j++)
        {
            if(array[j]<array[min])
            {
                min = j;
            }
        }

        if(min != i)    // 这句判断可要可不要
        {
            swap(array[i],array[min]);
        }
    }
 }    