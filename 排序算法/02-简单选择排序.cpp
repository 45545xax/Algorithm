

// 02-简单选择排序
/*
	爱炒股票短线的人，总是喜欢不断的买进卖出，想通过价差来实现盈利。但通常这种频繁操作的人，即使失误不多，也会因为操作的手续费和印花税过高而获利很少。
    还有一种做股票的人，他们很少出手，只是在不断的观察和判断，等到时机一到，果断买进或卖出。他们因为冷静和沉着，以及交易的次数少，而最终收益颇丰。 

    冒泡排序的思想就是不断的在交换，通过交换完成最终的排序，这和做股票短线频繁操作的人是类似的。
    我们可不可以像只有在时机非常明确到来时才出手的股票高手一样，也就是在排序时找到合适的关键字再做交换，
    并且只移动一次就完成相应关键字的排序定位工作呢？这就是选择排序法的初步思想。

    选择排序的基本思想是每一趟在n-i+1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。我们这里先介绍的是简单选择排序法。
    简单选择排序法（Simple Selection Sort）就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1≤i≤n)个记录交换之。
    我们来看代码。
*/
// 【交换函数】-C++ 版-模板：可以针对不同类型,不局限于 int 类型。
template <typename type>  
void swip(type &a, type &b)  
{  
    type temp = i;
    i = j;
    j = tmep; 
}  


void SelectSort0(int array[], int length)   // length 为数组的长度。
{
    int i,j,min;
    for(i = 0;i<length;i++)
    {
        min = i;
        for(j=i+1;j<length;j++)   
        {
            if( array[j]<array[min] ) 
            {
               min = j;
            }
        }

        if(i!=min)
        {
            swap(array[i],array[min]);
        }
         
    }
}


/*
     代码应该说不难理解，针对待排序的关键字序列是{9,1,5,8,3,7,4,6,2}，对i从1循环到8。当i=0时，array[i]=9，min开始是0，
     然后与j=1到8比较array[min]与array[j]的大小，因为j=1时最小，所以min=1。最终交换了array[1]与array[0]的值。
     注意，这里比较了8次，却只交换数据操作一次。
*/

/*
    复杂度分析：
    从简单选择排序的过程来看，它最大的特点就是【交换移动数据次数相当少】，这样也就节约了相应的时间。

    分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，

    而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，
    基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n^2)。

    应该说，尽管与冒泡排序同为O(n^2)，但简单选择排序的性能上还是要略优于冒泡排序。
*/

/*
    优化后的冒泡虽然最好的情况下时间复杂度为O(n)，但是出现概率比较小.
*/