

// 排序算法-01 
/*
	整理一下比较主流的几种排序算法，这篇介绍的排序算法有：1) 冒泡排序，2) 插入排序。
*/


// __________________________1 冒泡排序 __________________________
/*
	这已经成为了教科书式的排序算法了。很容易实现，且对部分已经排好序的数据进行排序时，具有比较好的效率。它的最坏情形是O(N2)。
	算法思路：以从小到大排序为例，每次从数组最后一个元素开始，比较相邻的两个元素，如果array[j]<array[j-1]，即后面的元素小于前面的元素，
	那么交换两者的顺序，然后j--，再比较j和j-1位置上的元素，直到最后，这样最小的元素就移动到了数组的前面。

	好比是将数组中的元素看成是不同重量的气泡，放在水中它们会自动在重力作用下，轻的上漂，重的下沉。这也是冒泡排序的原理。
	直接上代码：
*/

void BubbleSort(int array[], int nsize)
 {
     int i,j;
     bool bok=false;
     /***i指向冒泡的顶端***/
     /***如果哨兵为true,表明i位置以后的元素都已经排好序，直接退出***/
     for(i=0; (i<nsize-1)&&(bok!=true); i++)
     {
         bok = true;//重置哨兵
         /***j指向底端***/
         for(j=nsize-1; j>i; j--)
         {
             /***满足条件，交换元素***/
            if(array[j]<array[j-1])
            {
                swap(&array[j], &array[j-1]);
                bok = false;//设置哨兵为false，表明存在可以交换的元素
            }
         }
     }
 }	

 /*
以数组array={2,4,6,3,5,9,11}为例说明排序过程：

i=0:	2 3 4 6 5 9 11

i=1:	2 3 4 5 6 9 11

i=2:	bok=true,直接退出。

可以看看这个动画演示会更清楚：http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/maopaopaixu.htm
 */


// __________________________2 插入排序 __________________________
/*
	方法：从数组的二个元素开始，设当前位置索引是i，通过找到当前元素array[i]在前面i个元素中的正确位置j后，将j位置及j到i-1位置中间的元素后移一位，
	然后将当前元素插在j位置，这样前i个元素变成有序的了，然后i++,再通过比较和插入使得前i+1个元素有序，直到最后。
*/

void InsertSort(int arr[], int nlen)
{
    int i,j;
    int ntemp;
    for(i=1; i<nlen; i++)
    {
        ntemp = arr[i];
        for(j=i; j>0 && arr[j-1]>ntemp; j--)
            arr[j] = arr[j-1];
        arr[j] = ntemp;
    }
}	

/*
unsort array:
2 4 6 3 5 9 11
sort array:
2 3 4 5 6 9 11
*/

/*
	两种排序算法的时间复杂度都是O(N2)。但是冒泡排序增加了哨兵指示，用来判断是否当前排序已经处于有序状态，从而避免没必要的比较。
	在一般的小数据排序时，这两种都是很好的选择，因为实现起来简单。
*/