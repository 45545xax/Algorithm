

// 排序算法-02
/*
	前面讲了冒泡排序和插入排序，今天讲的排序算法是shell排序-希尔排序
*/


// __________________________1 希尔排序-shell排序 __________________________
/*
	shell排序命名来自于Donald Shell,该算法被证明为有亚二次时间界。是插入排序的一种改进，舍弃了插入排序逐一比较的不足之处，
    而是设定一个增量，间隔比较。然后逐渐缩小这个增量，最终达到排序目的，所以shell排序也叫缩减增量排序。

    首先，需要设定一组增量序列，h1,h2,...hk。然后先从h1开始，以此增量为步长，将全部序列分成若干组，每一组进行插入排序。
    接着增量变为h2，继续分组，然后再插入排序，这样直到最后。不同的增量序列带来的计算量不一样，
    本文以shell建议的增量序列为例进行算法说明，即h1=N/2,hk=hk-1/2。下面是具体步骤：
*/

void ShellSort(int arr[], int nlen)
{
    int i,j;
    int ntemp;
    int ngap;
    for(ngap=nlen/2; ngap>0; ngap/=2)//shell增量序列
    {
        for(i=ngap; i<nlen; i++)//对于每个增量序列hi(hi对应的初始位置是i),处理其后的所有元素i+1,i+2,..N-1
        {
            ntemp = arr[i];
            for(j=i; j>=ngap && arr[j-ngap]>ntemp; j-=ngap)//对当前位置i的元素,将其插入到arri-hi,arri-2hi,...序列中。
            {
                arr[j] = arr[j-ngap];//这个跟插入排序的过程是一样的
            }
            arr[j] = ntemp;

            /******for test*********/
            cout<<"gap="<<ngap<<": ";
            PrintArray(arr, nlen);
            /***********************/
        }
    }
}


// 测试
void PrintArray(int arr[], int nlen)
{
    int i;
    for(i=0; i<nlen; i++)
    {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

int _tmain(int argc, _TCHAR* argv[])
{
    int data[] = {2, 3, 1, 29, 70, 16, 34, 11, 10, 33, 79, 6, 46, 100, 25, 82};
    PrintArray(data, 16);
    ShellSort(data, 16);
    PrintArray(data, 16);

    return 0;
}

// 结果：

unsort 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82

gap=8: 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82
gap=8: 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82
gap=8: 2 3 1 29 70 16 34 11 10 33 79 6 46 100 25 82
gap=8: 2 3 1 6 70 16 34 11 10 33 79 29 46 100 25 82
gap=8: 2 3 1 6 46 16 34 11 10 33 79 29 70 100 25 82
gap=8: 2 3 1 6 46 16 34 11 10 33 79 29 70 100 25 82
gap=8: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=8: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 46 16 25 11 10 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 79 29 70 100 34 82
gap=4: 2 3 1 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=4: 2 3 1 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 16 25 11 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 46 33 34 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 33 46 29 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 100 79 82
gap=2: 1 3 2 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 3 2 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 25 16 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 34 29 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 34 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 34 46 33 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 82 79 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 79 82 100
gap=1: 1 2 3 6 10 11 16 25 29 33 34 46 70 79 82 100

sort:  1 2 3 6 10 11 16 25 29 33 34 46 70 79 82 100

 /*
自己动手分析一下结果就知道中间运行的具体过程了，很好理解。其实shell增量不一定是最好的，也可以选择其它的增量序列，这里不再叙述，<<数据结构与算法分析-c++描述>>的排序算法里面有介绍。
 */

