

// 07-快速排序

/*
介绍：
	 终于我们的高手要登场了，如果将来你工作后，你的老板要让你写个排序算法，而你会的算法中竟然没有快速排序，我想你还是不要声张，
   偷偷去把快速排序算法找来敲进电脑，这样至少你不至于被大伙儿取笑。

        事实上，不论是C++ STL、Java SDK或者.NET FrameWork SDK等开发工具包中的源代码里都能找到它的某种实现版本。 

        快速排序算法最早由图灵奖获得者Tony Hoare设计出来的，他在形式化方法理论，以及ALGOL60 编程语言的发明都有卓越的贡献，
        是上世纪最伟大的计算机科学家之一。而这快速排序算法只是他众多贡献中的一个小发明而已。

        更牛的是，我们现在要学习的这个快速排序算法，被列为20世纪10大算法之一。我们这些玩编程的人还有什么理由不去学习它呢？

        希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。
        而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。即它也是通过不断的比较和移动交换来实现排序的，
        只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，
        从而减少了总的比较次数和移动交换次数。
		
		参考来源：《大话数据结构》-伍迷
		https://www.cnblogs.com/cj723/archive/2011/04/27/2029993.html
*/


/*
历史背景：
  
*/


/*
思路来源：
 

    方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。
    这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），
    指向数字6。让哨兵j指向序列的最右边（即j=10），指向数字8。
	
    首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j--），
    直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。

    现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下。
       6  1  2  5  9 3  4  7  10  8


    到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。
    哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。
       6  1  2 5  4  3  9  7 10  8

    第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！
    此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下。
        3  1 2  5  4  6  9 7  10  8  

    到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，
    其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

    OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，
    右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，
    接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。


/*
    快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，
    将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。
    因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。
    因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。
    我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下。

*/

int a[101], n;       //定义全局变量，这两个变量需要在子函数中使用
quickSort(a[], 0, n);     //快速排序调用

void quickSort(int a[],int start,int end)
{
    if(start >= end)
       return;
                                    
    int base = a[start];   //temp中存的就是基准数
    int left = start;
    int right = end;
    while(left != right)
    {
       //顺序很重要，要先从右边开始找
       while(a[right] >= base && left < right) right--;
                
       //再找右边的
       while(a[left] <= base && left < right) left++;
                
       //交换两个数在数组中的位置
       if(left < right) swap(a[left], a[right]);
    }

    //最终将基准数归位
    a[start] = a[left];
    a[left] = base;
                                 
    quicksort(a[], start, left - 1);        //继续处理左边的，这里是一个递归的过程
    quicksort(a[], left + 1, end);       //继续处理右边的 ，这里是一个递归的过程
}


/*
分析：
快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次关键字的比较。

最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，
而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。时间复杂度为O(n*n)

在最好情况下，每次划分所取的基准都是当前无序区的"中值"记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。
总的关键字比较次数：O(nlgn)

尽管快速排序的最坏时间为O(n2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。
它的平均时间复杂度为O(nlgn)。
*/