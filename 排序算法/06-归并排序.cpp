

// 06-归并排序


/*
    归并：即将2个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：归并排序。
    要将一个数组排序，可以先(递归地)将它分成2半分别排序，然后将结果归并起来。

    归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比；它的主要缺点则是它所需要的额外空间和N成正比。
*/


/*
介绍：
	前面我们讲了堆排序，因为它用到了完全二叉树，充分利用了完全二叉树的深度是⌊log2n⌋+1的特性，所以效率比较高。不过堆结构的设计本身是比较复杂的，
老实说，能想出这样的结构就挺不容易，有没有更直接简单的办法利用完全二叉树来排序呢？当然是有。
    先来举一个例子。你们知道高考一本、二本、专科分数线是如何划分出来的吗？
    简单地说，如果各高校本科专业在某省高三理科学生中计划招收1万名，那么将全省参加高考的理科学生分数倒排序，
第1万名的总分数就是当年本科生的分数线（现实可能会比这复杂，这里简化之）。
也就是说，即使你是你们班级第一、甚至年级第一名，如果你没有上分数线，则说明你的成绩排不到全省前1万名，你也就基本失去了当年上本科的机会了。
    换句话说，所谓的全省排名，其实也就是每个市、每个县、每个学校、每个班级的排名合并后再排名得到的。注意我这里用到了合并一词。
我们要比较两个学生的成绩高低是很容易的，比如甲比乙分数低，丙比丁分数低。那么我们也就可以很容易得到甲乙丙丁合并后的成绩排名，同样的，
戊己庚辛的排名也容易得到，由于他们两组分别有序了，把他们八个学生成绩合并有序也是很容易做到的了，继续下去……最终完成全省学生的成绩排名，
此时高考状元也就诞生了。
    为了更清晰地说清楚这里的思想，大家来看图9-8-1，我们将本是无序的数组序列{16,7,13,10,9,15,3,2,5,8,12,1,11,4,6,14}，通过两两合并排序后，
再合并，最终获得了一个有序的数组。注意仔细观察它的形状，你会发现，它像极了一棵倒置的完全二叉树，通常涉及到完全二叉树结构的排序算法，
效率一般都不低的——这就是我们要讲的归并排序法。
*/


/*
历史背景：

*/


/*
思路来源：
	“归并”一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。
归并排序（Merging Sort）就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，
然后两两归并，得到⌈n/2⌉（⌈x⌉表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，
这种排序方法称为2路归并排序。 
    好了，有了对归并排序的初步认识后，我们来看代码。
*/


/* 对顺序表L作归并排序 */
void MergeSort(SqList *L)
{ 
  MSort(L->r,L->r,1,L->length);
}


/* 将SR[s..t]归并排序为TR1[s..t] */
void MSort(int SR[],int TR1[],int s, int t)
{
 int m;
 int TR2[MAXSIZE+1];
 if(s==t)
  TR1[s]=SR[s];
 else
 {
  m=(s+t)/2;   /* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */
  MSort(SR,TR2,s,m); /* 递归地将SR[s..m]归并为有序的TR2[s..m] */
  MSort(SR,TR2,m+1,t); /* 递归地将SR[m+1..t]归并为有序TR2[m+1..t] */
  Merge(TR2,TR1,s,m,t); /* 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] */
 }
}


/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */
void Merge(int SR[],int TR[],int i,int m,int n)
{
 int j,k,l;
 for(j=m+1,k=i;i<=m && j<=n;k++) /* 将SR中记录由小到大归并入TR */
 {
  if (SR[i]<SR[j])
   TR[k]=SR[i++];
  else
   TR[k]=SR[j++];
 }
 if(i<=m)
 {
  for(l=0;l<=m-i;l++)
   TR[k+l]=SR[i+l];  /* 将剩余的SR[i..m]复制到TR */
 }
 if(j<=n)
 {
  for(l=0;l<=n-j;l++)
   TR[k+l]=SR[j+l];  /* 将剩余的SR[j..n]复制到TR */
 }
}






  

