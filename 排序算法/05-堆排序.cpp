

// 05-堆排序

/*
历史背景：
  我们前面讲到简单选择排序，它在待排序的n个记录中选择一个最小的记录需要比较n-1次。本来这也可以理解，
  查找第一个数据需要比较这么多次正常的，否则如何知道它是最小的记录。

        可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，
  但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。
  如果可以做到每次在选择到最小的记录的同时，并根据比较对其他记录做出相应的调整，那样排序的总体效率就会非常高了。
  而堆排序（Heap Sort），就是对简单选择排序进行的一种改进，这种改进的效果是非常明显的。
  堆排序算法是Floyd和Williams在1964年共同发明的，同时，他们发明了堆这样的数据结构。

  堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，
   或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

  我们现在讲这个堆结构，其目的就是为了堆排序用的。

  
*/



/*
    http://www.cnblogs.com/wb-DarkHorse/archive/2012/12/08/2779219.html
    有不少图片在里面。

	前面介绍的冒泡排序，插入排序，shell排序都是基于两两元素比较，然后移动的排序算法，有着O(N2)的复杂度，
    今天讲三种比较牛的排序算法，可以将复杂度降低为O(n*lgn)。分别是：1) 堆排序。2)归并排序。3）快速排序。
*/

// __________________________1 堆排序 __________________________
/*
	算法：利用二叉堆(binary heap)的数据结构形式，及其性质对数据进行排序。首先看下什么是二叉堆，wiki解释：

二叉堆是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值，且每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。

二叉堆一般用数组来表示，节点i的左儿子的序号是2i，右儿子节点的下标是2i+1.如下面的两个二叉堆(左边的为最小堆，右边的为最大堆)表示的数组分别为：{1,2,3,4,5,6,7,8,9,10,11}和{11,9,10,5,6,7,8,1,2,3,4}。

        1               11
      /   \           /   \
     2     3         9     10
    / \   / \       / \    / \
   4   5  6  7     5   6  7   8
  / \ / \         / \ / \
 8  9 10 11      1  2 3  4 
二叉堆一般有集中基本操作，首先看一下，给一个数组，怎么建立一个二叉堆：

数组为array[] = {2, 3, 1, 29, 70, 16, 34, 11, 10, 33, 79};先根据数组下标，它构成的完全二叉树是这样的：
*/
