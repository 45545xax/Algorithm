

// 05-堆排序

/*
历史背景：
  我们前面讲到简单选择排序，它在待排序的n个记录中选择一个最小的记录需要比较n-1次。本来这也可以理解，
  查找第一个数据需要比较这么多次正常的，否则如何知道它是最小的记录。

        可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，
  但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。
  如果可以做到每次在选择到最小的记录的同时，并根据比较对其他记录做出相应的调整，那样排序的总体效率就会非常高了。
  而堆排序（Heap Sort），就是对简单选择排序进行的一种改进，这种改进的效果是非常明显的。
  堆排序算法是Floyd和Williams在1964年共同发明的，同时，他们发明了堆这样的数据结构。

  堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，
   或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

  我们现在讲这个堆结构，其目的就是为了堆排序用的。
*/


/*
思路来源：
    堆排序（Heap Sort）就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。
    此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），
    然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。
  
相信大家有些明白堆排序的基本思想了，不过要实现它还需要解决两个问题：
  （1）如何由一个无序序列构建成一个堆？
  （2）如果在输出堆顶元素后，调整剩余元素成为一个新的堆？要解释清楚它们，让我们来看代码。
*/











  


/*
    http://www.cnblogs.com/wb-DarkHorse/archive/2012/12/08/2779219.html
    有不少图片在里面。这篇讲的也不错呢。

	前面介绍的冒泡排序，插入排序，shell排序都是基于【两两元素比较】，然后移动的排序算法，有着O(N2)的复杂度，
    今天讲三种比较牛的排序算法，可以将复杂度降低为O(n*lgn)。分别是：1) 堆排序。2)归并排序。3）快速排序。
*/

// __________________________1 堆排序 __________________________
/*
	算法：利用二叉堆(binary heap)的数据结构形式，及其性质对数据进行排序。首先看下什么是二叉堆，wiki解释：

二叉堆是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值，
且每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。

二叉堆一般用数组来表示，节点i的左儿子的序号是2i，右儿子节点的下标是2i+1.如下面的两个二叉堆(左边的为最小堆，
右边的为最大堆)表示的数组分别为：{1,2,3,4,5,6,7,8,9,10,11}和{11,9,10,5,6,7,8,1,2,3,4}。

        1               11
      /   \           /   \
     2     3         9     10
    / \   / \       / \    / \
   4   5  6  7     5   6  7   8
  / \ / \         / \ / \
 8  9 10 11      1  2 3  4 
二叉堆一般有集中基本操作，首先看一下，给一个数组，怎么建立一个二叉堆：

数组为array[] = {2, 3, 1, 29, 70, 16, 34, 11, 10, 33, 79};先根据数组下标，它构成的完全二叉树是这样的：


           2              
       /      \           
      3        1       
    /   \    /   \     
   29   70  16   34    
  /  \  /  \        
 11 10 33  79   

明显这无法满足二叉堆的性质，所以我们要对其进行调整。由于我们要将数据从小到大排列，所以构建一个最大堆，即堆顶元素最大。
将要进行的操作叫做下滤(percolate down)。下面通过一步步的说明看下怎么实现的。

首先我们从上图中红色节点【70】开始(为什么要从红色节点开始？因为它是第一个拥有儿子节点的节点，没有儿子节点的节点不需要移动)。
比较其儿子节点，并找到最大的儿子节点，如果本父节点的值小于最大儿子节点，那么交换父节点和最大儿子节点。交换后树结构如下：

           2              
       /      \           
      3        1       
    /   \    /   \     
   29   79  16   34    
  /  \  /  \        
 11 10 33  70  

然后，当前节点左移一位(这时移动到29，如下图)，继续判断是否小于其子节点中的最大值，这里29>11,所以不需要交换。
继续左移一位，到达值为1的节点，判断然后交换后如下：

           2              
       /      \           
      3        34       
    /   \     /   \     
   29    79  16    1    
  /  \  /  \        
 11 10 33  70  

接着移动到值为3的节点，判断后应该是交换3和79。注意3的节点也有子节点，且此时破坏了原来的堆序性质，因为3<33&&3<70，
所以此时应该继续对3这个节点进行下滤，直到找到正确位置，类似于冒泡排序，小的节点直接沉到最低端。最后结果为：

           2              
       /      \           
      79        34       
    /   \     /   \     
   29    70  16    1    
  /  \  /  \        
 11 10 33  3 

然后继续移动当前节点到2，下滤完成以后，最后一个完好的二叉堆就新鲜出炉了。如下：

           79              
       /      \           
      70        34       
    /   \     /   \     
   29    33  16    1    
  /  \  /  \        
 11 10 2    3 

建好以后，下面就是排序了。我们知道最大堆的堆顶元素是最大的，那么我取出堆顶元素，放到一个新数组的最后，然后恢复最大堆的顺序，再取出堆顶，
放入新数组的倒数第二个，依次这样进行，最后得到的新数组就是一个递增排序好了的序列了。不过这样做，浪费空间，可以不用去申请一个新数组吗？
答案是：yes。如何实现？很简单，排序时，我们交换堆顶元素和堆底元素(其实就是数组的最后一个元素)，然后恢复堆的有序性，堆的大小减一，
即舍弃最后的那个最大的元素。接着再交换堆顶和堆底，继续恢复有序性，堆的大小减一，如此反复。。。。最后堆就是一个完全排好序的数组了。
是不是很简单？好吧，我承认还是有点复杂的。也许你会问：交换堆顶和堆底后，恢复堆的有序性不会很复杂吗？答案当然是：no！！，
因为要恢复堆的有序性，同样只是而且仅仅只是将堆顶元素执行下滤操作而已，这个其实是非常快的，复杂度是O(lgh),h是这个堆的高度。
ok，讲完了，上代码：

*/


void HeapSort(int arr[], int nsize)
{
    int i;
    for(i=nsize/2-1; i>=0; i--)
    {
        percolatedown(arr, nsize, i);//创建堆
    }

    for(i=nsize; i>0; i--)
    {
        swap(&arr[0],&arr[i-1]);//交换头尾元素
        percolatedown(arr, i-1, 0);//重新恢复堆序
    }
    
}
void percolatedown(int arr[], int nsize, int index)
{
    int ntemp;
    int nchild;
    for (ntemp=arr[index]; 2*index+1<=nsize-1; index=nchild)
    {
        nchild = 2*index+1;//左儿子节点序号
        if (nchild != nsize-1 && arr[nchild] < arr[nchild+1]) //如果存在右儿子，且左儿子小于右儿子
        {
            nchild++;//指向两个儿子中比较大的节点
        }
        if (ntemp < arr[nchild])//如果要下滤的值小于儿子节点
        {
            arr[index] = arr[nchild];//儿子节点上滤
        }
        else
            break;
    }
    arr[index] = ntemp;//将要下滤的节点放在最终正确的位置上
}