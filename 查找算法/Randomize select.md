# Randomize select algorithm 随机选择算法

从一个序列里面选择第k大的数在没有学习算法导论之前我想最通用的想法是给这个数组排序，然后按照排序结果返回第k大的数值。如果使用排序方法来做的话时间复杂度肯定至少为O（nlgn）。

问题是从序列中选择第k大的数完全没有必要来排序，可以采用分治法的思想解决这个问题。Randomize select 算法的期望时间复杂度可以达到O（n），这正是这个算法的迷人之处。具体的算法分析可以在《算法导论》这本书里查看。


一个n个元素组成的集合中，第K个顺序统计量（Order Statistic）指的是该集合中第K小的元素，我们要讨论的是如何在线性时间（linear time）里找出一个数组的第K个顺序统计量。

找最大值或最小值很简单，只需要遍历一次数组并记录下最大值或最小值就可以了。我们在这里要解决的问题是一般性的选择问题。

一种原始的解决方案是，用堆排序或归并排序将输入数据进行排序，然后返回第k个元素。这样在Θ(nlgn)时间内一定可以解决。但是我们希望有更好的方案，最好是线性时间。


## 期望线性时间的解决方案

为了在线性时间内解决这个选择问题，我们使用一个随机的分治算法，即RANDOMIZED-SELECT算法。此算法是使用随机化的快速排序中的随机划分子程序，对输入数组进行随机划分操作，然后判断第k小元素在划分后的哪个区域，对所在区域进行递归划分，最后找到第k小元素。

## O(n?)

这里的RANDOMIZED-PARTITION()是随机版的划分操作（快速排序的分析与优化），可见本算法是一个随机算法，它的期望时间是Θ(n)（假设元素的值是不同的）。

1、Lucky-Case：最好的情况是在正中划分，划分的右边和右边的元素数量相等，但是1/10和9/10的划分也几乎一样好。可以这么说，任何常数比例的划分都和1/2:1/2的划分一样好。这里以1/10和9/10的划分为例，算法运行时间递归式为T(n) <= T(9n/10) + Θ(n)，根据主定理得到T(n) <= Θ(n)。

2、Unlucky-Case：虽然主元的选取是随机的，但是如果你运气足够差，每次都得到0：n-1的划分，这就是最坏的情况。此时递归式为T(n) = T(n-1) + Θ(n)，则时间复杂度为T(n) = Θ(n^2)。

3、Expected-Time：期望运行时间为Θ(n)，即线性时间。这里就不证明了，证明需要用到指示器随机变量。


## 最坏情况线性时间的解决方案

虽然最坏情况Θ(n^2)出现的概率非常非常小，但是不代表它不会出现。这里就介绍一个非同一般的算法，以保证在最坏情况下也能达到线性时间。

这个SELECT算法的基本思想就是要保证对数组的划分是一个好的划分，它通过自己的方法选取主元（pivot），然后将pivot作为参数传递给快速排序的确定性划分操作PARTITION。

基本步骤：

将输入数组的n个元素划分为n/5（上取整）组，每组5个元素，且至多只有一个组有剩下的n%5个元素组成。

寻找每个组织中中位数。首先对每组中的元素（至多为5个）进行插入排序，然后从排序后的序列中选择出中位数。

对第2步中找出的n/5（上取整）个中位数，递归调用SELECT以找出其中位数x。（如果是偶数取下中位数）

调用PARTITION过程，按照中位数x对输入数组进行划分。确定中位数x的位置k。

如果i=k，则返回x。否则，如果i < k，则在地区间递归调用SELECT以找出第i小的元素，若干i > k，则在高区找第(i-k)个最小元素。

	// 参考文章 ： http://songlee24.github.io/2014/06/22/Kth-Order-Statistic/