
## 树状递归
>
http://t1174779123.iteye.com/blog/2124357 

递归专题
此文章所在专题列表如下：  
漫谈递归：递归的思想  
漫谈递归：递归需要满足的两个条件  
漫谈递归：字符串回文现象的递归判断  
漫谈递归：二分查找算法的递归实现  
漫谈递归：递归的效率问题  
漫谈递归：递归与循环  
漫谈递归：循环与迭代是一回事吗？  
递归计算过程与迭代计算过程  
漫谈递归：从斐波那契开始了解尾递归  
漫谈递归：尾递归与CPS  
漫谈递归：补充一些Continuation的知识  
漫谈递归：PHP里的尾递归及其优化  
漫谈递归：从汇编看尾递归的优化  
>
http://any9.com/939.html


如何理解 SICP-1.2.2 树形递归空间需求线性增长？
>
http://www.douban.com/group/topic/67330078/

尾调用优化
>
http://www.ruanyifeng.com/blog/2015/04/tail-call.html



## 斐波那契数列的递归求法


根据定义很容易写出的斐波那契数列:

	int Fibonacci(int n) {
	    if (n<=2) {
	        return 1;
	    }
	    else {
	        return Fibonacci(n-1) + Fibonacci(n-2);
	    }
	}

但是面试官接着问这样不断的压栈很浪费内存空间，问是否可以优化？可能很多人给不出其他解法了，或者说感觉其他解法如果也是递归的话，也需要压栈，一样会占用内存空间。其实，面试官想考察的是尾递归。

## 尾递归  
>
在计算机科学里，**尾调用**是指一个函数里的最后一个动作是一个函数调用的情形即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。
>
尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。

尾递归因而具有两个特征：  
 
 - 调用自身函数(Self-called)；   
 - 计算仅占用常量栈空间(Stack Space)。 

而形式上只要是最后一个return语句返回的是一个完整函数，它就是**尾递归**。

由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作**尾调用消除**(Tail Call Elimination)或**尾调用优化**(Tail Call Optimization, TCO)。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。

一般来说，尾调用消除是可选的。然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，这让程序员可以用递归替换循环而不丧失性能。

简单理解，就是处于函数尾部的递归调用本身的情形下，前面的变量状态都不需要再保存了，可以释放，从而节省很大的内存空间。在前面的代码中，明显在调用递归调用Fibonacci(n-1)的时候，还有Fibonacci(n-2)没有执行，需要保存前面的状态，因此开销较大的。

于是，我们可以改写这个斐波那契数列：

	// 求斐波那契数列 第N项 
	Fibonacci(n, 1, 1)； 

	int Fibonacci(int n, int a, int b) {
	    if (n<=2) {
	        return b;
	    }
	    else {
	        return Fibonacci(n-1, b, a+b);
	    }
	}


